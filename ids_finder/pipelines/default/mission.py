# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../notebooks/pipelines/10_mission.ipynb.

# %% auto 0
__all__ = ['combine_features', 'vector_project', 'vector_project_pl', 'compute_inertial_length', 'compute_Alfven_speed',
           'compute_Alfven_current', 'decompose_vector', 'calc_combined_features', 'create_combined_data_pipeline']

# %% ../../../notebooks/pipelines/10_mission.ipynb 2
from ... import PARAMS
import polars as pl
import polars.selectors as cs

from typing import Optional

# %% ../../../notebooks/pipelines/10_mission.ipynb 4
def combine_features(candidates: pl.LazyFrame, states_data: pl.LazyFrame):

    return candidates.with_columns( 
        cs.datetime().dt.cast_time_unit("ns"), # issue: https://github.com/pola-rs/polars/issues/12023
    ).sort("time").join_asof(states_data.sort("time"), on="time")

# %% ../../../notebooks/pipelines/10_mission.ipynb 7
import astropy.units as u
from astropy.constants import mu0, e
from plasmapy.formulary.lengths import inertial_length
from plasmapy.formulary.speeds import Alfven_speed
from xarray_einstats import linalg
from ...utils.basic import df2ts, pl_norm
import xarray as xr

# %% ../../../notebooks/pipelines/10_mission.ipynb 8
def vector_project(v1,v2, dim="v_dim"):
    return xr.dot(v1 , v2, dims=dim) / linalg.norm(v2, dims=dim)

def vector_project_pl(df: pl.DataFrame, v1_cols, v2_cols, name=None):
    
    v1 = df2ts(df, v1_cols).assign_coords(v_dim=["r","t","n"])
    v2 = df2ts(df, v2_cols).assign_coords(v_dim=["r","t","n"]) 
    result = vector_project(v1, v2, dim="v_dim")
    
    return df.with_columns(
        pl.Series(result.data).alias(name or "v_proj")
    )

# %% ../../../notebooks/pipelines/10_mission.ipynb 10
def compute_inertial_length(ldf: pl.LazyFrame, density_col = "plasma_density"):
    df = ldf.collect()

    density = df[density_col].to_numpy() * u.cm ** (-3)
    result = inertial_length(density, "H+").to(u.km)

    return df.with_columns(ion_inertial_length=pl.Series(result.value)).lazy()

# %% ../../../notebooks/pipelines/10_mission.ipynb 12
def compute_Alfven_speed(ldf: pl.LazyFrame):
    df = ldf.collect()

    B = df["B"] if "B" in df.columns else df["b_mag"]  # backwards compatiblity
    density = df["plasma_density"].to_numpy() * u.cm ** (-3)
    result = Alfven_speed(B.to_numpy() * u.nT, density=density, ion="p+").to(u.km / u.s)

    return df.with_columns(Alfven_speed=pl.Series(result.value)).lazy()


def compute_Alfven_current(ldf: pl.LazyFrame):
    df = ldf.collect()

    Alfven_speed = df["Alfven_speed"].to_numpy() * u.km / u.s
    density = df["plasma_density"].to_numpy() * u.cm ** (-3)

    result = (e.si * Alfven_speed * density)
    result = result.to(u.nA / u.m**2)

    return df.with_columns(j_Alfven=pl.Series(result.value)).lazy()

# %% ../../../notebooks/pipelines/10_mission.ipynb 14
def decompose_vector(df: pl.LazyFrame, vector_col, name=None):
    if name is None:
        name = vector_col

    return df.with_columns(
        pl.col(vector_col).list.get(0).alias(f"{name}_x"),
        pl.col(vector_col).list.get(1).alias(f"{name}_y"),
        pl.col(vector_col).list.get(2).alias(f"{name}_z"),
    )


def calc_combined_features(df: pl.LazyFrame):
    vec_cols = ["v_x", "v_y", "v_z"]  # plasma velocity vector in any coordinate system

    j_factor = ((u.nT / u.s) * (1 / mu0 / (u.km / u.s))).to(u.nA / u.m**2)

    vector_cols = ["Vl", "Vn", "normal_direction"]

    result = (
        df.with_columns(
            duration=pl.col("d_tstop") - pl.col("d_tstart"),
        )
        .pipe(decompose_vector, "normal_direction", name="k")
        .pipe(decompose_vector, "Vl")
        .with_columns(cs.by_name(vector_cols).list.to_array(3))
        .pipe(vector_project_pl, vec_cols, "Vl", name="v_l")
        .pipe(vector_project_pl, vec_cols, "Vn", name="v_n")
        .pipe(vector_project_pl, vec_cols, "normal_direction", name="v_k")
        .with_columns(
            pl.col("v_n").abs(),
            pl.col("v_k").abs(),
            v_mn=(pl.col("plasma_speed") ** 2 - pl.col("v_l") ** 2).sqrt(),
        )
        .with_columns(
            L_n=pl.col("v_n") * pl.col("duration").dt.nanoseconds() / 1e9,
            L_mn=pl.col("v_mn") * pl.col("duration").dt.nanoseconds() / 1e9,
            L_k=pl.col("v_k") * pl.col("duration").dt.nanoseconds() / 1e9,
            j0=pl.col("d_star") / pl.col("v_mn"),
            j0_k=pl.col("d_star") / pl.col("v_k"),
        )
        .pipe(compute_inertial_length)
        .pipe(compute_Alfven_speed)
        .pipe(compute_Alfven_current)
        .with_columns(
            cs.by_name("j0", "j0_k") * j_factor.value,
        )
        .with_columns(
            cs.by_name(
                vector_cols
            ).arr.to_list()  # PanicException: not yet implemented: Writing FixedSizeList to parquet not yet implemented
        )
    )
    return result

# %% ../../../notebooks/pipelines/10_mission.ipynb 16
from kedro.pipeline import Pipeline, node
from kedro.pipeline.modular_pipeline import pipeline
from ...utils.basic import load_params

# %% ../../../notebooks/pipelines/10_mission.ipynb 17
def create_combined_data_pipeline(
    sat_id, # satellite id, used for namespace
    params : Optional[dict] = None,
    **kwargs
) -> Pipeline:
    
    if params is None:
        params = PARAMS
    
    tau = params["tau"]
    ts_mag = params[sat_id]["MAG"]["time_resolution"]
    ts_state = params[sat_id]["STATE"]["time_resolution"]
    
    ts_mag_str = f"ts_{ts_mag}s"
    ts_state_str = f"ts_{ts_state}s"
    tau_str = f"tau_{tau}s"

    node_combine_features = node(
        combine_features,
        inputs=[
            f"MAG.feature_{ts_mag_str}_{tau_str}",
            f"STATE.primary_data_{ts_state_str}",
        ],
        outputs="combined_data",
    )

    node_calc_new_features = node(
        calc_combined_features,
        inputs="combined_data",
        outputs=f"events_{ts_mag_str}_{tau_str}",
    )

    nodes = [node_combine_features, node_calc_new_features]
    return pipeline(
        nodes,
        namespace=sat_id,
        outputs={
            f"events_{ts_mag_str}_{tau_str}": f"events.{sat_id}_{ts_mag_str}_{tau_str}",
        }
    )
